<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://xincao20.gitee.io/blog/atom.xml" rel="self"/>
  
  <link href="https://xincao20.gitee.io/blog/"/>
  <updated>2021-12-14T08:18:06.330Z</updated>
  <id>https://xincao20.gitee.io/blog/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL实战笔记</title>
    <link href="https://xincao20.gitee.io/blog/2021/12/18/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E5%92%8C%E4%B8%8D%E9%9A%94%E7%A6%BB/"/>
    <id>https://xincao20.gitee.io/blog/2021/12/18/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E5%92%8C%E4%B8%8D%E9%9A%94%E7%A6%BB/</id>
    <published>2021-12-18T13:39:40.781Z</published>
    <updated>2021-12-14T08:18:06.330Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="学习重点"><a href="#学习重点" class="headerlink" title="学习重点"></a>学习重点</h3><h1 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1. 基础篇"></a>1. 基础篇</h1><h2 id="1-查询语句的执行"><a href="#1-查询语句的执行" class="headerlink" title="1. 查询语句的执行"></a>1. 查询语句的执行</h2><p><strong>MySQL逻辑架构图</strong></p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180221.png" alt="img"></p><h3 id="1-Server层"><a href="#1-Server层" class="headerlink" title="1. Server层"></a>1. Server层</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>Server层包括连接器、分析器、优化器、执行器、查询缓存。</p><h4 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h4><p>作用：</p><ol><li><p>负责跟客户端建立连接</p></li><li><p>获取权限</p></li><li><p>维持和管理连接</p></li></ol><p>连接指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>获取权限：通过TCP握手后，连接器验证身份，通过输入的用户名和密码。查询MySQL数据库中的user表。查询对应的用户权限。</p><p><strong>长连接和短链接</strong></p><p>长连接：连接成功后，如果客户端持续有请求，则一直使用该连接</p><p>短连接：每次执行完几次查询就断开连接，下次查询在重新建立连接。</p><p>建议使用长连接，因为建立连接过程比较复杂，尽量减少建立连接的动作。</p><p>但是建立长连接也会导致内存消耗增加。因为Mysql在执行时使用的内存是在连接对象里面的。这些资源会在断开时释放。</p><p>如果长连接累计下来，可能导致内存占用太大。</p><p>解决方法</p><ol><li>定期断开长连接</li><li>执行mysql_reset_connectionc初始化连接资源。针对5.7以后。</li></ol><h4 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2. 查询缓存"></a>2. 查询缓存</h4><p>作用：</p><ol><li>用于做缓存</li></ol><p>Mysql拿到请求后会先去缓存中，查看是否有对应的查询语句。缓存以key-value的形式存储。</p><p>查询语句作为key ,查询结果作为value存入缓存中。</p><p>但是不建议使用查询缓存。因为缓存数据失效的很频繁。</p><p><strong>8.0之后MySQL删掉了查询缓存</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//缓存查询</span><br><span class="line"></span><br><span class="line">select  SQL_CACHE *  from T ;</span><br><span class="line"></span><br><span class="line">// 不查询缓存</span><br><span class="line">select   DEMAND *  from T ; </span><br></pre></td></tr></table></figure><h4 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h4><p>作用： 进行sql语句的解析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where ID=1;</span><br></pre></td></tr></table></figure><ol><li>词法分析</li></ol><p>通过关键字 <strong>select</strong> 识别为查询语句。将对应的T识别成对应的表名T，将字符串”ID” 识别成列”ID”.</p><ol><li>语法分析</li></ol><p>判断Sql语句是否满足Mysql语法。如果语句不对，则会受到错误提醒。</p><h4 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h4><p>作用：决定执行方案</p><ol><li>决定使用哪个索引，多个索引情况下。</li><li>决定各表连接顺序，多个表关联的情况下。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li></ul><p>优化器会决定执行哪种方案。</p><h4 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h4><p>作用：执行sql语句</p><ol><li>判断用户对这个表有无查询权限</li><li>根据表引擎提供的接口执行查询</li></ol><ul><li><p>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</p></li><li><p>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</p></li><li><p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p></li></ul><h2 id="2-更新语句的执行"><a href="#2-更新语句的执行" class="headerlink" title="2. 更新语句的执行"></a>2. 更新语句的执行</h2><h3 id="1-架构图"><a href="#1-架构图" class="headerlink" title="1. 架构图"></a>1. 架构图</h3><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180222.png" alt="img"></p><p>更新还涉及到redo log（重做日志）和binlog（归档日志）</p><h3 id="2-Redo-log-引擎日志"><a href="#2-Redo-log-引擎日志" class="headerlink" title="2.Redo log(引擎日志)"></a>2.Redo log(引擎日志)</h3><p>老板记账：先把借帐和还账记在黑板上，空闲时，再把黑板上账的写入到账本中。</p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180223.png" alt="img"></p><ol><li>WAL (Write-Ahead Logging)</li></ol><p>先写日志，再写磁盘。</p><p>InnoDB引擎会把记录写道redo log中，并更新内存。然后更新就算完成。引擎会在空闲时间操作记录</p><p>写入磁盘。</p><p>如果redo log写满了，会把一部分记录更新到磁盘中。</p><p>通过write pos 和check point 两个指针来判断日志是否写满</p><ol><li>crash-safe</li></ol><p>当数据库发生异常时，可以通过redo log 可以获取到之前的提交记录。</p><p>通过提交记录可以将未同步到数据库中数据同步到数据库中。</p><p>存储的是物理变更日志，用于记录磁盘中指定地方的数值修改记录。</p><h3 id="3-binlog（Server-层日志）"><a href="#3-binlog（Server-层日志）" class="headerlink" title="3. binlog（Server 层日志）"></a>3. binlog（Server 层日志）</h3><p>存储的是Mysql执行的sql语句记录。</p><h3 id="4-执行流程"><a href="#4-执行流程" class="headerlink" title="4. 执行流程"></a>4. 执行流程</h3><ol><li><p>执行引擎先找到ID=2的这一行数据，如果内存中存在直接返回给执行器，否则从磁盘读入内存然后返回给执行器</p></li><li><p>把值加上1，然后调用引擎接口写入数据</p></li><li><p>引擎会将新数据更新到内存中，同时更新到redo log中。redo log处于prepare状态，告诉执行器完成了，可以提交事务了。</p></li><li><p>执行器生成更新操作的bin log,并把bin log写入磁盘</p></li><li><p>执行器调用引擎的事务接口，将写入的redo log 改成commit状态</p></li></ol><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180224.jpg" alt="img"></p><h3 id="5-两阶段提交"><a href="#5-两阶段提交" class="headerlink" title="5. 两阶段提交"></a>5. 两阶段提交</h3><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180225.png" alt="img"></p><p><strong>原因</strong></p><ol><li>如果发生crash导致系统崩溃的话，如果顺序不一致，可能导致之后无法通过binlog恢复到任一时刻的数据</li><li>可能导致binlog和redo log的数据不一致导致数据冲突。</li></ol><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="5-两种日志的不同点"><a href="#5-两种日志的不同点" class="headerlink" title="5. 两种日志的不同点"></a>5. 两种日志的不同点</h3><ol><li><p>redo log 是 InnoDB引擎特有的，binlog是MySQL的Server层实现的</p></li><li><p>redo log 是物理日志，记录的是  <strong>在某个数据页上做了修改</strong>，binlog是逻辑日志记录的是语句逻辑 <strong>给ID=2的数据进行加1</strong></p></li><li><p>redo log 是循环写，空间大小固定。bin log 是追加写，当bin log文件到达一定大小后会切换到下一个，不会覆盖以前的日志</p></li></ol><h2 id="3-事务隔离"><a href="#3-事务隔离" class="headerlink" title="3. 事务隔离"></a>3. 事务隔离</h2><h3 id="1-隔离性和隔离级别"><a href="#1-隔离性和隔离级别" class="headerlink" title="1. 隔离性和隔离级别"></a>1. 隔离性和隔离级别</h3><ol><li><p><strong>事务特性：</strong></p></li><li><p><strong>原子性</strong></p></li><li><p><strong>持久性</strong></p></li><li><p><strong>隔离性</strong></p></li><li><p><strong>一致性</strong></p></li></ol><ol><li><p><strong>事务隔离级别：</strong></p></li><li><p><strong>读已提交（事务未提交时，变更能被其它事务看到）</strong></p></li><li><p><strong>读未提交（事务提交后，其它事务才能看到变更）</strong></p></li><li><p><strong>可重复读（一个事务执行过程中，总是跟启动时看到的数据是一致的。未提交的变更对其它事务不可见）</strong></p></li><li><p><strong>串行化（同一行记录写会加写锁，读会读锁。当出现读写锁冲突时，后访问的事务，必须等前一个事务完成，才能执行）</strong></p></li></ol><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180226.png" alt="img"></p><p> v1=v2=1,v3=2</p><p>四种事务得到的结果</p><ol><li><p>读未提交： v1、v2、v3=2</p></li><li><p>读已提交: v1=1 ，v2、v3=2</p></li><li><p>可重复读：v1=v2=1，v3=2</p></li><li><p>可串行化 ： v1=v2=1,v3=2</p></li></ol><h3 id="2-事务隔离的实现"><a href="#2-事务隔离的实现" class="headerlink" title="2. 事务隔离的实现"></a>2. 事务隔离的实现</h3><p>当一个值从1按顺序变成2，3，3那么他的日志里面就会有类似的回滚段记录</p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180227.png" alt="img"></p><p>当回滚段日志过长时，系统会自动清除。</p><h3 id="3-事务的启动方式"><a href="#3-事务的启动方式" class="headerlink" title="3. 事务的启动方式"></a>3. 事务的启动方式</h3><ol><li><p>关闭自动提交，手动执行commit或是rollback来执行回滚</p></li><li><p>begin 或是start transaction 提交语句commit rollback</p></li></ol><h2 id="4-索引"><a href="#4-索引" class="headerlink" title="4. 索引"></a>4. 索引</h2><h3 id="1-索引常见模型"><a href="#1-索引常见模型" class="headerlink" title="1.索引常见模型"></a>1.索引常见模型</h3><h4 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h4><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180228.png" alt="img"></p><p>通过hash算法将key换算成确定的位置，然后把value放入到这个数组的位置。如果数组已经存在值，</p><p>则通过拉链法，拉出一条链表。</p><p>优点：等值查询的情况下查询效率高</p><p>缺点：范围查询效率低下</p><h4 id="2-有序数组"><a href="#2-有序数组" class="headerlink" title="2. 有序数组"></a>2. 有序数组</h4><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180229.png" alt="img"></p><p>优点：等值和范围查询效率高</p><p>缺点：插入、删除数据效率低下</p><p>场景：只适用于静态存储引擎</p><h4 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3. 二叉搜索树"></a>3. 二叉搜索树</h4><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180230.png" alt="img"></p><p>缺点：数据量大的情况下，导致树很高，需要进行多次磁盘读取数据，比较浪费时间。</p><h3 id="2-InnoDB索引模型"><a href="#2-InnoDB索引模型" class="headerlink" title="2. InnoDB索引模型"></a>2. InnoDB索引模型</h3><p>B+树</p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180231.png" alt="img"></p><h4 id="1-主键索引和非主键索引"><a href="#1-主键索引和非主键索引" class="headerlink" title="1. 主键索引和非主键索引"></a>1. 主键索引和非主键索引</h4><p><strong>InnoDB里面主键索引也被称为聚簇索引</strong></p><p>非主键索引的叶子节点存储的是主键的值</p><p>主键索引和非主键索引的区别</p><ol><li>主键查询： 只需要查询主键索引的B+树,查询出对应的数据</li><li>非主键索引：查询非主键索引的树，获得对应的主键值，然后通过主键值查询主键索引的B+树</li></ol><h3 id="3-索引维护"><a href="#3-索引维护" class="headerlink" title="3. 索引维护"></a>3. 索引维护</h3><p>B+树在数据更新的时候会进行维护。而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><h3 id="4-索引覆盖"><a href="#4-索引覆盖" class="headerlink" title="4.索引覆盖"></a>4.索引覆盖</h3><p> select * from T where k between 3 and 5</p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180232.png" alt="img"></p><p>执行流程</p><ol><li><p>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</p></li><li><p>再到 ID 索引树查到 ID=300 对应的 R3；</p></li><li><p>在 k 索引树取下一个值 k=5，取得 ID=500；</p></li><li><p>再回到 ID 索引树查到 ID=500 对应的 R4；</p></li><li><p>在 k 索引树取下一个值 k=6，不满足条件，循环结束</p></li></ol><p><strong>回表：非主键搜索完后，回到主键索引树进行搜索的过程</strong>。（步骤2、4）</p><p>select ID from T where k between 3 and 5</p><p>对于上述通过非主键索引查询主键索引信息，由于非主键索引存放了主键的信息。</p><p>导致我们不需要进行回表。<strong>由于索引k的值覆盖了查询的字段，我们称之为覆盖索引</strong></p><p><strong>优点：减少树的搜索次数，提升查询效率</strong></p><h3 id="5-最左前缀原则"><a href="#5-最左前缀原则" class="headerlink" title="5.最左前缀原则"></a>5.最左前缀原则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tuser` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `id_card` varchar(32) DEFAULT NULL,</span><br><span class="line">  `name` varchar(32) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `ismale` tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180233.png" alt="img"></p><p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p><p><strong>联合索引以第一个索引为基准进行排序，然后通过第一个索引的值来进行查询</strong></p><p><a href="https://www.cnblogs.com/ljl150/p/12934071.html">最左前缀原则</a></p><h3 id="6-索引下推"><a href="#6-索引下推" class="headerlink" title="6.索引下推"></a>6.索引下推</h3><p>Mysql5.6引入索引下推，是在最左前缀的条件小，过滤调不不符合条件的记录减少回表的次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#x27;张 %&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180234.png" alt="img"></p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180235.png" alt="img"></p><h2 id="5-锁"><a href="#5-锁" class="headerlink" title="5.锁"></a>5.锁</h2><p><strong>根据加锁范围分类：</strong></p><ol><li><p><strong>全局锁</strong></p></li><li><p><strong>表级锁</strong></p></li><li><p><strong>行锁</strong></p></li></ol><h3 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1. 全局锁"></a>1. 全局锁</h3><p>全局读锁命令</p><p><strong>全局锁就是对整个数据库实例加锁，Mysql 提供了一个加全局读锁的命令。可以让整个数据库处于只读状态。</strong></p><p>导致数据的增删改、建表修改表语句、事务的提交语句失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure><p>场景：<strong>全库的逻辑备份(<strong><strong>也可以开启可重复读事务级别来进行备份</strong></strong>)</strong></p><p>另一种方式是使用mysqldump工具使用参数-single-transaction进行数据库备份。前提：数据库中所有的表支持可重复读。</p><p>场景：用户买课和买课后的余额。不加锁导致两个表的数据前后不一致。</p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180236.png" alt="img"></p><h3 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2. 表级锁"></a>2. 表级锁</h3><ol><li>两种表锁</li></ol><ul><li>表锁</li><li>元数据锁</li></ul><ol><li>表锁</li></ol><p>作用：<strong>锁定表只能进行读或读和写操作。不允许操作其他表。（<strong><strong>处理并发的常用方式</strong></strong>）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock tables t1 read, t2 write;</span><br></pre></td></tr></table></figure><p>只能对t1表进行读，t2表进行读和写。直到执行<strong>unlock tables</strong>之前不允许对其他表进行读写操作。</p><ol><li>MDL ( meatadata lock)</li></ol><p>作用：保证读写的正确性。</p><p>特点： 自动加上，不需要使用sql语句。在对表进行数据的增删改查操作时加读锁。修改表结构时，加写锁。</p><p>读读锁共存、读写锁、写写锁互斥。</p><p><strong>示例</strong></p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016205707.png" alt="img"></p><p>在多个事务开启且未结束的过程中给某个表添加个字段导致读写锁冲突。</p><p>解决方法</p><p>在information_schema 库中 innodb_trx 表中查询出正在执行事务，可以暂停表变更事务、或者是长事务。</p><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><ol><li>全局锁主要是用来逻辑备份，有两种方式一种是通过命令 flush tables with read lock;。另一种需要支持库中所有的表支持可重复读事务，使用mysqldump -single-transaction 进行备份。</li></ol><ol><li>表锁通过sql语句限制指定表只能进行读、读/写操作,且不允许对其他表操作在解锁前。</li></ol><ol><li>MDL是自动加上的，不需要通过sql语句。存在读写锁、写写锁互斥情况。锁在事务提交后释放。作用是为了防止DDL和DML操作冲突。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m</summary>
      
    
    
    
    <category term="数据库" scheme="https://xincao20.gitee.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://xincao20.gitee.io/blog/tags/Mysql/"/>
    
    <category term="数据库" scheme="https://xincao20.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql实战" scheme="https://xincao20.gitee.io/blog/tags/Mysql%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实战笔记</title>
    <link href="https://xincao20.gitee.io/blog/2021/12/18/MySQL45%E8%AE%B2%E7%AC%94%E8%AE%B0/"/>
    <id>https://xincao20.gitee.io/blog/2021/12/18/MySQL45%E8%AE%B2%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-18T13:39:40.770Z</published>
    <updated>2021-12-14T08:18:18.169Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="学习重点"><a href="#学习重点" class="headerlink" title="学习重点"></a>学习重点</h3><h1 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1. 基础篇"></a>1. 基础篇</h1><h2 id="1-查询语句的执行"><a href="#1-查询语句的执行" class="headerlink" title="1. 查询语句的执行"></a>1. 查询语句的执行</h2><p><strong>MySQL逻辑架构图</strong></p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180221.png" alt="img"></p><h3 id="1-Server层"><a href="#1-Server层" class="headerlink" title="1. Server层"></a>1. Server层</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>Server层包括连接器、分析器、优化器、执行器、查询缓存。</p><h4 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h4><p>作用：</p><ol><li><p>负责跟客户端建立连接</p></li><li><p>获取权限</p></li><li><p>维持和管理连接</p></li></ol><p>连接指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>获取权限：通过TCP握手后，连接器验证身份，通过输入的用户名和密码。查询MySQL数据库中的user表。查询对应的用户权限。</p><p><strong>长连接和短链接</strong></p><p>长连接：连接成功后，如果客户端持续有请求，则一直使用该连接</p><p>短连接：每次执行完几次查询就断开连接，下次查询在重新建立连接。</p><p>建议使用长连接，因为建立连接过程比较复杂，尽量减少建立连接的动作。</p><p>但是建立长连接也会导致内存消耗增加。因为Mysql在执行时使用的内存是在连接对象里面的。这些资源会在断开时释放。</p><p>如果长连接累计下来，可能导致内存占用太大。</p><p>解决方法</p><ol><li>定期断开长连接</li><li>执行mysql_reset_connectionc初始化连接资源。针对5.7以后。</li></ol><h4 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2. 查询缓存"></a>2. 查询缓存</h4><p>作用：</p><ol><li>用于做缓存</li></ol><p>Mysql拿到请求后会先去缓存中，查看是否有对应的查询语句。缓存以key-value的形式存储。</p><p>查询语句作为key ,查询结果作为value存入缓存中。</p><p>但是不建议使用查询缓存。因为缓存数据失效的很频繁。</p><p><strong>8.0之后MySQL删掉了查询缓存</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//缓存查询</span><br><span class="line"></span><br><span class="line">select  SQL_CACHE *  from T ;</span><br><span class="line"></span><br><span class="line">// 不查询缓存</span><br><span class="line">select   DEMAND *  from T ; </span><br></pre></td></tr></table></figure><h4 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h4><p>作用： 进行sql语句的解析。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where ID=1;</span><br></pre></td></tr></table></figure><ol><li>词法分析</li></ol><p>通过关键字 <strong>select</strong> 识别为查询语句。将对应的T识别成对应的表名T，将字符串”ID” 识别成列”ID”.</p><ol><li>语法分析</li></ol><p>判断Sql语句是否满足Mysql语法。如果语句不对，则会受到错误提醒。</p><h4 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h4><p>作用：决定执行方案</p><ol><li>决定使用哪个索引，多个索引情况下。</li><li>决定各表连接顺序，多个表关联的情况下。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li></ul><p>优化器会决定执行哪种方案。</p><h4 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h4><p>作用：执行sql语句</p><ol><li>判断用户对这个表有无查询权限</li><li>根据表引擎提供的接口执行查询</li></ol><ul><li><p>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</p></li><li><p>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</p></li><li><p>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p></li></ul><h2 id="2-更新语句的执行"><a href="#2-更新语句的执行" class="headerlink" title="2. 更新语句的执行"></a>2. 更新语句的执行</h2><h3 id="1-架构图"><a href="#1-架构图" class="headerlink" title="1. 架构图"></a>1. 架构图</h3><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180222.png" alt="img"></p><p>更新还涉及到redo log（重做日志）和binlog（归档日志）</p><h3 id="2-Redo-log-引擎日志"><a href="#2-Redo-log-引擎日志" class="headerlink" title="2.Redo log(引擎日志)"></a>2.Redo log(引擎日志)</h3><p>老板记账：先把借帐和还账记在黑板上，空闲时，再把黑板上账的写入到账本中。</p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180223.png" alt="img"></p><ol><li>WAL (Write-Ahead Logging)</li></ol><p>先写日志，再写磁盘。</p><p>InnoDB引擎会把记录写道redo log中，并更新内存。然后更新就算完成。引擎会在空闲时间操作记录</p><p>写入磁盘。</p><p>如果redo log写满了，会把一部分记录更新到磁盘中。</p><p>通过write pos 和check point 两个指针来判断日志是否写满</p><ol><li>crash-safe</li></ol><p>当数据库发生异常时，可以通过redo log 可以获取到之前的提交记录。</p><p>通过提交记录可以将未同步到数据库中数据同步到数据库中。</p><p>存储的是物理变更日志，用于记录磁盘中指定地方的数值修改记录。</p><h3 id="3-binlog（Server-层日志）"><a href="#3-binlog（Server-层日志）" class="headerlink" title="3. binlog（Server 层日志）"></a>3. binlog（Server 层日志）</h3><p>存储的是Mysql执行的sql语句记录。</p><h3 id="4-执行流程"><a href="#4-执行流程" class="headerlink" title="4. 执行流程"></a>4. 执行流程</h3><ol><li><p>执行引擎先找到ID=2的这一行数据，如果内存中存在直接返回给执行器，否则从磁盘读入内存然后返回给执行器</p></li><li><p>把值加上1，然后调用引擎接口写入数据</p></li><li><p>引擎会将新数据更新到内存中，同时更新到redo log中。redo log处于prepare状态，告诉执行器完成了，可以提交事务了。</p></li><li><p>执行器生成更新操作的bin log,并把bin log写入磁盘</p></li><li><p>执行器调用引擎的事务接口，将写入的redo log 改成commit状态</p></li></ol><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180224.jpg" alt="img"></p><h3 id="5-两阶段提交"><a href="#5-两阶段提交" class="headerlink" title="5. 两阶段提交"></a>5. 两阶段提交</h3><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180225.png" alt="img"></p><p><strong>原因</strong></p><ol><li>如果发生crash导致系统崩溃的话，如果顺序不一致，可能导致之后无法通过binlog恢复到任一时刻的数据</li><li>可能导致binlog和redo log的数据不一致导致数据冲突。</li></ol><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="5-两种日志的不同点"><a href="#5-两种日志的不同点" class="headerlink" title="5. 两种日志的不同点"></a>5. 两种日志的不同点</h3><ol><li><p>redo log 是 InnoDB引擎特有的，binlog是MySQL的Server层实现的</p></li><li><p>redo log 是物理日志，记录的是  <strong>在某个数据页上做了修改</strong>，binlog是逻辑日志记录的是语句逻辑 <strong>给ID=2的数据进行加1</strong></p></li><li><p>redo log 是循环写，空间大小固定。bin log 是追加写，当bin log文件到达一定大小后会切换到下一个，不会覆盖以前的日志</p></li></ol><h2 id="3-事务隔离"><a href="#3-事务隔离" class="headerlink" title="3. 事务隔离"></a>3. 事务隔离</h2><h3 id="1-隔离性和隔离级别"><a href="#1-隔离性和隔离级别" class="headerlink" title="1. 隔离性和隔离级别"></a>1. 隔离性和隔离级别</h3><ol><li><p><strong>事务特性：</strong></p></li><li><p><strong>原子性</strong></p></li><li><p><strong>持久性</strong></p></li><li><p><strong>隔离性</strong></p></li><li><p><strong>一致性</strong></p></li></ol><ol><li><p><strong>事务隔离级别：</strong></p></li><li><p><strong>读已提交（事务未提交时，变更能被其它事务看到）</strong></p></li><li><p><strong>读未提交（事务提交后，其它事务才能看到变更）</strong></p></li><li><p><strong>可重复读（一个事务执行过程中，总是跟启动时看到的数据是一致的。未提交的变更对其它事务不可见）</strong></p></li><li><p><strong>串行化（同一行记录写会加写锁，读会读锁。当出现读写锁冲突时，后访问的事务，必须等前一个事务完成，才能执行）</strong></p></li></ol><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180226.png" alt="img"></p><p> v1=v2=1,v3=2</p><p>四种事务得到的结果</p><ol><li><p>读未提交： v1、v2、v3=2</p></li><li><p>读已提交: v1=1 ，v2、v3=2</p></li><li><p>可重复读：v1=v2=1，v3=2</p></li><li><p>可串行化 ： v1=v2=1,v3=2</p></li></ol><h3 id="2-事务隔离的实现"><a href="#2-事务隔离的实现" class="headerlink" title="2. 事务隔离的实现"></a>2. 事务隔离的实现</h3><p>当一个值从1按顺序变成2，3，3那么他的日志里面就会有类似的回滚段记录</p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180227.png" alt="img"></p><p>当回滚段日志过长时，系统会自动清除。</p><h3 id="3-事务的启动方式"><a href="#3-事务的启动方式" class="headerlink" title="3. 事务的启动方式"></a>3. 事务的启动方式</h3><ol><li><p>关闭自动提交，手动执行commit或是rollback来执行回滚</p></li><li><p>begin 或是start transaction 提交语句commit rollback</p></li></ol><h2 id="4-索引"><a href="#4-索引" class="headerlink" title="4. 索引"></a>4. 索引</h2><h3 id="1-索引常见模型"><a href="#1-索引常见模型" class="headerlink" title="1.索引常见模型"></a>1.索引常见模型</h3><h4 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h4><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180228.png" alt="img"></p><p>通过hash算法将key换算成确定的位置，然后把value放入到这个数组的位置。如果数组已经存在值，</p><p>则通过拉链法，拉出一条链表。</p><p>优点：等值查询的情况下查询效率高</p><p>缺点：范围查询效率低下</p><h4 id="2-有序数组"><a href="#2-有序数组" class="headerlink" title="2. 有序数组"></a>2. 有序数组</h4><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180229.png" alt="img"></p><p>优点：等值和范围查询效率高</p><p>缺点：插入、删除数据效率低下</p><p>场景：只适用于静态存储引擎</p><h4 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3. 二叉搜索树"></a>3. 二叉搜索树</h4><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180230.png" alt="img"></p><p>缺点：数据量大的情况下，导致树很高，需要进行多次磁盘读取数据，比较浪费时间。</p><h3 id="2-InnoDB索引模型"><a href="#2-InnoDB索引模型" class="headerlink" title="2. InnoDB索引模型"></a>2. InnoDB索引模型</h3><p>B+树</p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180231.png" alt="img"></p><h4 id="1-主键索引和非主键索引"><a href="#1-主键索引和非主键索引" class="headerlink" title="1. 主键索引和非主键索引"></a>1. 主键索引和非主键索引</h4><p><strong>InnoDB里面主键索引也被称为聚簇索引</strong></p><p>非主键索引的叶子节点存储的是主键的值</p><p>主键索引和非主键索引的区别</p><ol><li>主键查询： 只需要查询主键索引的B+树,查询出对应的数据</li><li>非主键索引：查询非主键索引的树，获得对应的主键值，然后通过主键值查询主键索引的B+树</li></ol><h3 id="3-索引维护"><a href="#3-索引维护" class="headerlink" title="3. 索引维护"></a>3. 索引维护</h3><p>B+树在数据更新的时候会进行维护。而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</p><h3 id="4-索引覆盖"><a href="#4-索引覆盖" class="headerlink" title="4.索引覆盖"></a>4.索引覆盖</h3><p> select * from T where k between 3 and 5</p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180232.png" alt="img"></p><p>执行流程</p><ol><li><p>在 k 索引树上找到 k=3 的记录，取得 ID = 300；</p></li><li><p>再到 ID 索引树查到 ID=300 对应的 R3；</p></li><li><p>在 k 索引树取下一个值 k=5，取得 ID=500；</p></li><li><p>再回到 ID 索引树查到 ID=500 对应的 R4；</p></li><li><p>在 k 索引树取下一个值 k=6，不满足条件，循环结束</p></li></ol><p><strong>回表：非主键搜索完后，回到主键索引树进行搜索的过程</strong>。（步骤2、4）</p><p>select ID from T where k between 3 and 5</p><p>对于上述通过非主键索引查询主键索引信息，由于非主键索引存放了主键的信息。</p><p>导致我们不需要进行回表。<strong>由于索引k的值覆盖了查询的字段，我们称之为覆盖索引</strong></p><p><strong>优点：减少树的搜索次数，提升查询效率</strong></p><h3 id="5-最左前缀原则"><a href="#5-最左前缀原则" class="headerlink" title="5.最左前缀原则"></a>5.最左前缀原则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tuser` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `id_card` varchar(32) DEFAULT NULL,</span><br><span class="line">  `name` varchar(32) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `ismale` tinyint(1) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `id_card` (`id_card`),</span><br><span class="line">  KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE=InnoDB</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180233.png" alt="img"></p><p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p><p><strong>联合索引以第一个索引为基准进行排序，然后通过第一个索引的值来进行查询</strong></p><p><a href="https://www.cnblogs.com/ljl150/p/12934071.html">最左前缀原则</a></p><h3 id="6-索引下推"><a href="#6-索引下推" class="headerlink" title="6.索引下推"></a>6.索引下推</h3><p>Mysql5.6引入索引下推，是在最左前缀的条件小，过滤调不不符合条件的记录减少回表的次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#x27;张 %&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180234.png" alt="img"></p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180235.png" alt="img"></p><h2 id="5-锁"><a href="#5-锁" class="headerlink" title="5.锁"></a>5.锁</h2><p><strong>根据加锁范围分类：</strong></p><ol><li><p><strong>全局锁</strong></p></li><li><p><strong>表级锁</strong></p></li><li><p><strong>行锁</strong></p></li></ol><h3 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1. 全局锁"></a>1. 全局锁</h3><p>全局读锁命令</p><p><strong>全局锁就是对整个数据库实例加锁，Mysql 提供了一个加全局读锁的命令。可以让整个数据库处于只读状态。</strong></p><p>导致数据的增删改、建表修改表语句、事务的提交语句失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure><p>场景：<strong>全库的逻辑备份(<strong><strong>也可以开启可重复读事务级别来进行备份</strong></strong>)</strong></p><p>另一种方式是使用mysqldump工具使用参数-single-transaction进行数据库备份。前提：数据库中所有的表支持可重复读。</p><p>场景：用户买课和买课后的余额。不加锁导致两个表的数据前后不一致。</p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180236.png" alt="img"></p><h3 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2. 表级锁"></a>2. 表级锁</h3><ol><li>两种表锁</li></ol><ul><li>表锁</li><li>元数据锁</li></ul><ol><li>表锁</li></ol><p>作用：<strong>锁定表只能进行读或读和写操作。不允许操作其他表。（<strong><strong>处理并发的常用方式</strong></strong>）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock tables t1 read, t2 write;</span><br></pre></td></tr></table></figure><p>只能对t1表进行读，t2表进行读和写。直到执行<strong>unlock tables</strong>之前不允许对其他表进行读写操作。</p><ol><li>MDL ( meatadata lock)</li></ol><p>作用：保证读写的正确性。</p><p>特点： 自动加上，不需要使用sql语句。在对表进行数据的增删改查操作时加读锁。修改表结构时，加写锁。</p><p>读读锁共存、读写锁、写写锁互斥。</p><p><strong>示例</strong></p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016205707.png" alt="img"></p><p>在多个事务开启且未结束的过程中给某个表添加个字段导致读写锁冲突。</p><p>解决方法</p><p>在information_schema 库中 innodb_trx 表中查询出正在执行事务，可以暂停表变更事务、或者是长事务。</p><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><ol><li>全局锁主要是用来逻辑备份，有两种方式一种是通过命令 flush tables with read lock;。另一种需要支持库中所有的表支持可重复读事务，使用mysqldump -single-transaction 进行备份。</li></ol><ol><li>表锁通过sql语句限制指定表只能进行读、读/写操作,且不允许对其他表操作在解锁前。</li></ol><ol><li>MDL是自动加上的，不需要通过sql语句。存在读写锁、写写锁互斥情况。锁在事务提交后释放。作用是为了防止DDL和DML操作冲突。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m</summary>
      
    
    
    
    <category term="数据库" scheme="https://xincao20.gitee.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://xincao20.gitee.io/blog/tags/Mysql/"/>
    
    <category term="数据库" scheme="https://xincao20.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql实战" scheme="https://xincao20.gitee.io/blog/tags/Mysql%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>JUC</title>
    <link href="https://xincao20.gitee.io/blog/2021/12/18/JUC/"/>
    <id>https://xincao20.gitee.io/blog/2021/12/18/JUC/</id>
    <published>2021-12-18T12:47:34.000Z</published>
    <updated>2021-12-18T13:15:44.607Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​</p><h1 id="1-并发基础"><a href="#1-并发基础" class="headerlink" title="1. 并发基础"></a>1. 并发基础</h1><h2 id="1-多线程实现"><a href="#1-多线程实现" class="headerlink" title="1. 多线程实现"></a>1. 多线程实现</h2><h3 id="1-实现方法分类"><a href="#1-实现方法分类" class="headerlink" title="1. 实现方法分类"></a>1. 实现方法分类</h3><ol><li>继承 Thread 类，重写 run 方法</li><li>实现 Runnable 接口，实现 run 方法</li></ol><p>​</p><h3 id="2-两种方法对比"><a href="#2-两种方法对比" class="headerlink" title="2.两种方法对比"></a>2.两种方法对比</h3><ul><li>实现 runnable 接口更好</li></ul><ol><li> Java 只支持单继承，继承 Thread 类导致程序拓展性不好</li><li> 解耦，将创建线程和线程任务调度分离了</li></ol><ul><li>两种方法本质区别对比</li></ul><ol><li>继承 Thread 类是通过重写 Thread 类的方法</li><li>实现 Runnable 是在 Thread 类中调用 Runnable 实现类的 run 方法</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1632972177969-fad65c06-bcc6-44e4-b2b1-6ca907ef17f6.png#clientId=uc78e1191-c90c-4&from=paste&height=88&id=u87fc8e3c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=175&originWidth=798&originalType=binary&ratio=1&size=17698&status=done&style=none&taskId=ue1385ff3-9acf-4f86-9c7b-9dc189b4937&width=399" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1632975139265-558c5dc8-a5c9-4d7e-a3a2-f7776812b1d3.png#clientId=uc78e1191-c90c-4&from=paste&height=179&id=uf1f15e3b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=358&originWidth=911&originalType=binary&ratio=1&size=208968&status=done&style=none&taskId=u470653a7-2d58-4d6c-8e55-e0f0f3b1a54&width=455.5" alt="image.png"></p><p><strong>思考题：同时使用两种方法实现多线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BothRunnableThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//实现Runnable接口的方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;我来自Runnable&quot;</span>);</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="comment">//重写Thread类的run方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我来自Thread&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br>​</p><p>我来自 Thread<br>​</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p><strong>实现线程创建的方法:只有一种通过 Thread 类来创建线程</strong><br><strong>实现线程执行方法：</strong></p><ol><li><strong>实现 Runnable 接口的 run 方法，并把接口实例传给 Thread 类在其 Thread 类中的 run 方法中调用</strong></li><li><strong>重写 Thread 类的 run 方法</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1632972177969-fad65c06-bcc6-44e4-b2b1-6ca907ef17f6.png#clientId=uc78e1191-c90c-4&from=paste&height=88&id=E0Gbe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=175&originWidth=798&originalType=binary&ratio=1&size=17698&status=done&style=none&taskId=ue1385ff3-9acf-4f86-9c7b-9dc189b4937&width=399" alt="image.png"><br>​</p><p>​</p><p>​</p><p>​</p><p>​</p><h3 id="错误观点"><a href="#错误观点" class="headerlink" title="错误观点"></a>错误观点</h3><ol><li>线程池也是创建线程的一种方式（其本质还是通过 Thread 类来创建线程）</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1632973964491-96ae041b-cac4-4e5c-9c8f-5a06fcf1da7f.png#clientId=uc78e1191-c90c-4&from=paste&height=152&id=u79391c98&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=951&originalType=binary&ratio=1&size=42157&status=done&style=none&taskId=u93535749-5529-4f24-9947-c8d937f09d8&width=475.5" alt="image.png"></p><ol start="2"><li>Callable 也是创建线程的一种方式（本质是调用其创建一个内部线程执行 run 方法在 run 方法内部调用 callable 的 call 方法）</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1632976285825-263a51fb-e842-4cec-8206-67a41403c8ac.png#clientId=uc78e1191-c90c-4&from=paste&height=312&id=u645da87e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=624&originWidth=917&originalType=binary&ratio=1&size=58810&status=done&style=none&taskId=ufa52c3d1-c751-48ce-a2ed-806eaadbca4&width=458.5" alt="image.png"><a href="https://blog.csdn.net/xzongyuan/article/details/71378769">FutureTask 与 Callable 的本质</a><br>​</p><p>​</p><h3 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h3><h4 id="1-多少种线程实现方法"><a href="#1-多少种线程实现方法" class="headerlink" title="1. 多少种线程实现方法"></a>1. 多少种线程实现方法</h4><p>参考总结</p><h4 id="2-Runnable-和-Thread-类那种方法实现多线程更好"><a href="#2-Runnable-和-Thread-类那种方法实现多线程更好" class="headerlink" title="2. Runnable 和 Thread 类那种方法实现多线程更好"></a>2. Runnable 和 Thread 类那种方法实现多线程更好</h4><p>Runnable 好</p><ol><li>职责分离： Runnable 定义了执行内容，Thread 类用于创建线程权责分明</li><li>提高性能：每次执行一次任务，都需要新建一个独立的线程，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类，整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。</li><li>Java 只支持单继承</li></ol><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><h2 id="2-线程的启动"><a href="#2-线程的启动" class="headerlink" title="2. 线程的启动"></a>2. 线程的启动</h2><h3 id="1-start-和-run-方法比较"><a href="#1-start-和-run-方法比较" class="headerlink" title="1. start 和 run 方法比较"></a>1. start 和 run 方法比较</h3><h4 id="1-start-方法"><a href="#1-start-方法" class="headerlink" title="1. start 方法"></a>1. start 方法</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol><li> 启动新线程</li><li> 新线程的准备工作</li></ol><h5 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h5><p><strong>执行流程</strong></p><ol><li><strong>判断线程状态</strong></li><li><strong>将线程加入线程组</strong></li><li><strong>调用 start0 方法</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Causes this thread to begin execution; the Java Virtual Machine</span></span><br><span class="line"><span class="comment">    * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * The result is that two threads are running concurrently: the</span></span><br><span class="line"><span class="comment">    * current thread (which returns from the call to the</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</span></span><br><span class="line"><span class="comment">    * &lt;code&gt;run&lt;/code&gt; method).</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * It is never legal to start a thread more than once.</span></span><br><span class="line"><span class="comment">    * In particular, a thread may not be restarted once it has completed</span></span><br><span class="line"><span class="comment">    * execution.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@exception</span>  IllegalThreadStateException  if the thread was already</span></span><br><span class="line"><span class="comment">    *               started.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        #run()</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span>        #stop()</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">        * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">        * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">        * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">        * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">       group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           start0();</span><br><span class="line">           started = <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                   group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">               <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                 it will be passed up the call stack */</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="2-run-方法"><a href="#2-run-方法" class="headerlink" title="2. run 方法"></a>2. run 方法</h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><ol><li>执行该线程任务</li></ol><p>​</p><p>​</p><h5 id="源码解读-1"><a href="#源码解读-1" class="headerlink" title="源码解读"></a>源码解读</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * If this thread was constructed using a separate</span></span><br><span class="line"><span class="comment">  * &lt;code&gt;Runnable&lt;/code&gt; run object, then that</span></span><br><span class="line"><span class="comment">  * &lt;code&gt;Runnable&lt;/code&gt; object&#x27;s &lt;code&gt;run&lt;/code&gt; method is called;</span></span><br><span class="line"><span class="comment">  * otherwise, this method does nothing and returns.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>     #start()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>     #stop()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">         target.run();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="3-面试题"><a href="#3-面试题" class="headerlink" title="3. 面试题"></a>3. 面试题</h4><p>​</p><ol><li>两次调用 start 方法会出现什么情况？</li></ol><p>参考 start 方法源码解读</p><ol start="2"><li>为什么不能直接调用 run 方法</li></ol><p>start 方法用于创建新的线程，如果直接调用 run 方法则是有 main 线程调用 run 方法<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartAndRunMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;;</span><br><span class="line">        runnable.run();</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">main</span><br><span class="line">Thread-<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-停止线程"><a href="#3-停止线程" class="headerlink" title="3. 停止线程"></a>3. 停止线程</h2><p><strong>interupt 停止线程原理：通知线程停止，但是不强制停止线程。由线程的 run 方法决定是否停止。</strong></p><h3 id="1-正确停止线程"><a href="#1-正确停止线程" class="headerlink" title="1. 正确停止线程"></a>1. 正确停止线程</h3><p>方法 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程中断程序结束&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;go&quot;</span>);</span><br><span class="line">            throwInMethod();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">throwInMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//sleep()、wait()等会抛中断异常的方法在抛出异常之前会清除线程的中断标识</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法 2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RightWayStopThreadInProd2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;go&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                throwInMethod();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">throwInMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RightWayStopThreadInProd2());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-错误的停止方法"><a href="#2-错误的停止方法" class="headerlink" title="2. 错误的停止方法"></a>2. 错误的停止方法</h3><ol><li>调用 stop 方法</li><li>用 volatile 设置 boolean 标记位</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrongWayVolatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        BlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">30</span>);</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer(blockingQueue);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!consumer.needMoreNums()) &#123;</span><br><span class="line"></span><br><span class="line">                producer.canceled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            Object take = blockingQueue.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费者开始消费&quot;</span> + take);</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue blockingQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">10000</span> &amp;&amp; !canceled) &#123;<span class="comment">//线程中断的地方</span></span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    blockingQueue.put(num);<span class="comment">//导致线程不能中断的地方是由于put一直处于阻塞状态</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者生产完成&quot;</span> + num);</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 概率约为95%的随机消费</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">needMoreNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> random = Math.random();</span><br><span class="line">        <span class="keyword">if</span> (random &gt; <span class="number">0.96</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue blockingQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-线程的生命周期"><a href="#4-线程的生命周期" class="headerlink" title="4. 线程的生命周期"></a>4. 线程的生命周期</h2><h3 id="1-线程的-6-种状态"><a href="#1-线程的-6-种状态" class="headerlink" title="1. 线程的 6 种状态"></a>1. 线程的 6 种状态</h3><ul><li>New 创建了线程但是没有执行 start 方法</li><li>Runnable 调用了 start 方法后变成 Runnable 状态</li><li>Blocked 线程进入<strong>Synchronized 修饰的方法或者代码块</strong>但是锁被其他线程拿走</li><li>Waiting wait() 、Thread.join() 、LockSupport.park() 只能等待唤醒信号唤醒</li><li>Timed Waiting wait(time) sleep(time) join(time) parkNanos(time) parkUntiil(time) 等待信号唤醒或超时</li><li>Terminated</li></ul><p>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1632994078056-1d0b44a7-e1ec-4a61-b1f4-7357293c0a0a.png#clientId=uc78e1191-c90c-4&from=paste&height=431&id=u441c7a4d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=861&originWidth=803&originalType=binary&ratio=1&size=307491&status=done&style=none&taskId=u5a1795f8-b0dd-45e6-bbb3-ffcafc2e65e&width=401.5" alt="image.png"></p><h3 id="2-阻塞状态"><a href="#2-阻塞状态" class="headerlink" title="2. 阻塞状态"></a>2. 阻塞状态</h3><p>Blocked、Waiting、TimedWaiting</p><h2 id="5-Thread-类和-Object-类线程方法详解"><a href="#5-Thread-类和-Object-类线程方法详解" class="headerlink" title="5. Thread 类和 Object 类线程方法详解"></a>5. Thread 类和 Object 类线程方法详解</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633157925874-a5caca19-3c10-41d3-b92f-393282718634.png#clientId=ud9dfac8a-0ab2-4&from=paste&height=388&id=u2fd4f1a0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=775&originWidth=1590&originalType=binary&ratio=1&size=962383&status=done&style=none&taskId=u92fdbb0c-ee29-4830-89c4-fdac321aa81&width=795" alt="image.png"></p><h3 id="1-wait、notify、notifyAll-方法详解"><a href="#1-wait、notify、notifyAll-方法详解" class="headerlink" title="1. wait、notify、notifyAll 方法详解"></a>1. wait、notify、notifyAll 方法详解</h3><ol><li>阻塞阶段</li></ol><p>执行 wait 方法进入阻塞阶段</p><p>唤醒方法</p><ul><li>其他线程调用 notify 方法刚好唤醒阻塞线程</li><li>调用 notifyAll 唤醒所有阻塞线程</li><li>过了超时时间，自动唤醒</li><li>线程自身调用 interupt 方法</li></ul><p>​</p><ol start="2"><li>唤醒阶段</li></ol><p>通过调用 notify 或者 notifyAll 方法<br>​</p><ol start="3"><li>遇到中断</li></ol><h3 id="2-wait、notify、notifyAll-特点和性质"><a href="#2-wait、notify、notifyAll-特点和性质" class="headerlink" title="2. wait、notify、notifyAll 特点和性质"></a>2. wait、notify、notifyAll 特点和性质</h3><ul><li>调用 wait 方法之前必须要拥有 monitor</li><li>notify 只能唤醒其中一个</li><li>都属于 object 类</li></ul><h3 id="3-wait-原理"><a href="#3-wait-原理" class="headerlink" title="3. wait 原理"></a>3. wait 原理</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633185389200-d6496003-0e72-419a-ada9-11f03a0eadd2.png#clientId=ud9dfac8a-0ab2-4&from=paste&height=347&id=u54b8a244&margin=%5Bobject%20Object%5D&name=image.png&originHeight=693&originWidth=739&originalType=binary&ratio=1&size=390644&status=done&style=none&taskId=u8858d183-b105-4207-a257-d1802c0f057&width=369.5" alt="image.png"></p><ol><li>线程进入线程节点集</li><li>线程节点集中的节点尝试获取锁</li><li>调用 wait 方法释放锁进入等待集</li><li>等待集中的线程等待其他线程调用 notify、notifyAll 方法将线程唤醒（线程由等待状态转为 Blocked）</li><li>重新唤醒的线程尝试重新获取锁</li><li>释放锁并退出</li></ol><h3 id="4-join-方法"><a href="#4-join-方法" class="headerlink" title="4. join 方法"></a>4. join 方法</h3><ol><li>作用</li></ol><p>因为新的线程要加入我们，所以我们等他执行完再执行</p><ol start="2"><li>用法</li></ol><p>主线程等待需要加入的线程执行完毕<br>​</p><p>​</p><h2 id="6-线程未被捕获异常"><a href="#6-线程未被捕获异常" class="headerlink" title="6. 线程未被捕获异常"></a>6. 线程未被捕获异常</h2><h3 id="1-异常处理器解决方法"><a href="#1-异常处理器解决方法" class="headerlink" title="1. 异常处理器解决方法"></a>1. 异常处理器解决方法</h3><ol><li>在 run 方法中捕获异常并处理</li><li>实现 UncaughtExceptionHandler 接口</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633315130302-db04aac5-f7b3-47cd-a64d-27568b1185d0.png#clientId=u23d15eed-d2bc-4&from=paste&height=165&id=u7bb4f8b8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=330&originWidth=789&originalType=binary&ratio=1&size=49802&status=done&style=none&taskId=udbf3fc47-8b17-486c-a35f-833cd6c5e81&width=394.5" alt="image.png"></p><p>源码解析<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断线程是否存在父线程的异常处理器</span></span><br><span class="line">       <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">           parent.uncaughtException(t, e);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//获取线程默认异常处理器</span></span><br><span class="line">           Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">               Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">           <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//调用线程默认异常处理器</span></span><br><span class="line">               ueh.uncaughtException(t, e);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">               <span class="comment">//没有直接打印异常</span></span><br><span class="line">               System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span></span><br><span class="line">                                + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">               e.printStackTrace(System.err);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-自定义异常处理器"><a href="#2-自定义异常处理器" class="headerlink" title="2. 自定义异常处理器"></a>2. 自定义异常处理器</h3><ol><li>实现 Thread.UncaughtExceptionHandler 的 uncaught 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        Logger logger=Logger.getAnonymousLogger();</span><br><span class="line">        logger.log(Level.WARNING,<span class="string">&quot;自定义异常处理器&quot;</span>+t.getName(),e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>设置线程异常处理器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseOwnUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler());</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseOwnUncaughtExceptionHandler());</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseOwnUncaughtExceptionHandler());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> UseOwnUncaughtExceptionHandler());</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-线程安全"><a href="#7-线程安全" class="headerlink" title="7. 线程安全"></a>7. 线程安全</h2><h3 id="1-什么是线程安全"><a href="#1-什么是线程安全" class="headerlink" title="1. 什么是线程安全"></a>1. 什么是线程安全</h3><p><strong>多个线程访问某个对象或方法时，在编写方法或对象的业务逻辑时，不需要做额外的处理（可以像单线程编程一样），程序可以正常运行（不会因为多线程而出错）</strong><br><strong>​</strong></p><h3 id="2-线程安全问题"><a href="#2-线程安全问题" class="headerlink" title="2. 线程安全问题"></a>2. 线程安全问题</h3><ol><li>运行结果错误：a++多线程问题</li><li>活跃性问题：死锁、活锁、饥饿</li><li>对象发布和初始化安全问题</li></ol><p><strong>​</strong></p><h2 id="8-死锁"><a href="#8-死锁" class="headerlink" title="8. 死锁"></a>8. 死锁</h2><h3 id="1-死锁概念"><a href="#1-死锁概念" class="headerlink" title="1. 死锁概念"></a>1. 死锁概念</h3><p>特点</p><ul><li>发生在并发中</li><li>互不相让</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633750091741-d8a67152-fa3d-4dc5-9ae7-e7092e9bbd04.png#clientId=u71005f6c-83ec-4&from=paste&height=301&id=uf260c5fc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=1298&originalType=binary&ratio=1&size=98661&status=done&style=none&taskId=ubca3f96e-a8ce-4c24-806c-6610f5939f4&width=649" alt="image.png"></p><h3 id="2-死锁事例"><a href="#2-死锁事例" class="headerlink" title="2. 死锁事例"></a>2. 死锁事例</h3><ol><li>两个用户转账</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/10/9</span></span><br><span class="line"><span class="comment"> * 转账时遇到死锁情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoney</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Account from = <span class="keyword">new</span> Account(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">static</span> Account to = <span class="keyword">new</span> Account(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TransferMoney user1 = <span class="keyword">new</span> TransferMoney();</span><br><span class="line">        TransferMoney user2 = <span class="keyword">new</span> TransferMoney();</span><br><span class="line">        user1.flag = <span class="number">0</span>;</span><br><span class="line">        user2.flag = <span class="number">1</span>;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(user1);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(user2);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        thread1.join();</span><br><span class="line">        System.out.println(from.balance);</span><br><span class="line">        System.out.println(to.balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            transferMoney(from, to, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            transferMoney(to, from, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account from, Account to, <span class="keyword">int</span> account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                <span class="keyword">if</span> (from.balance - account &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(from + <span class="string">&quot;转账用户余额不足&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                from.balance -= account;</span><br><span class="line">                to.balance += account;</span><br><span class="line">                System.out.println(from + <span class="string">&quot;转账成功&quot;</span> + account + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>多个用户转账</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/10/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiTransferMoney</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账户数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMS_ACCOUNT = <span class="number">500</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账户初始化金额数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMS_MONEY = <span class="number">10000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转账次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMS_TRANSFERS = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM_THREDS = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Random rdm = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TransferMoney.Account[] accounts = <span class="keyword">new</span> TransferMoney.Account[NUMS_ACCOUNT];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMS_ACCOUNT; i++) &#123;</span><br><span class="line">            accounts[i] = <span class="keyword">new</span> TransferMoney.Account(NUMS_MONEY);</span><br><span class="line">        &#125;</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREDS; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> TransferMoneyThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoneyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMS_TRANSFERS; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> accountFromIndex;</span><br><span class="line">                <span class="keyword">int</span> accountToIndex;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    accountFromIndex = rdm.nextInt(NUMS_ACCOUNT);</span><br><span class="line">                    accountToIndex = rdm.nextInt(NUMS_ACCOUNT);</span><br><span class="line">                &#125; <span class="keyword">while</span> (accountFromIndex == accountToIndex);</span><br><span class="line">                <span class="keyword">int</span> money = rdm.nextInt(NUMS_MONEY);</span><br><span class="line">                TransferMoney.transferMoney(accounts[accountFromIndex], accounts[accountToIndex], money);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;转账结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-死锁条件"><a href="#3-死锁条件" class="headerlink" title="3. 死锁条件"></a>3. 死锁条件</h3><ol><li>**互斥条件 **</li><li><strong>请求与保持条件</strong></li><li><strong>不剥夺条件</strong></li><li><strong>循环等待条件</strong></li></ol><h3 id="4-定位死锁"><a href="#4-定位死锁" class="headerlink" title="4. 定位死锁"></a>4. 定位死锁</h3><h4 id="1-Jstack"><a href="#1-Jstack" class="headerlink" title="1. Jstack"></a>1. Jstack</h4><ol><li>通过 jps 获取 Java 运行程序的 pid</li><li>通过 jstack pid 查看对应程序的死锁情况</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">J:\JavaBase\cocurrency_tools_practice&gt;jps</span><br><span class="line">16672 TransferMoney</span><br><span class="line">17784</span><br><span class="line">19592 Jps</span><br><span class="line">4236 Launcher</span><br><span class="line"></span><br><span class="line">J:\JavaBase\cocurrency_tools_practice&gt;jstack 16672</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-修复死锁"><a href="#5-修复死锁" class="headerlink" title="5. 修复死锁"></a>5. 修复死锁</h3><h3 id="1-避免策略"><a href="#1-避免策略" class="headerlink" title="1. 避免策略"></a>1. 避免策略</h3><h1 id="2-并发高级"><a href="#2-并发高级" class="headerlink" title="2. 并发高级"></a>2. 并发高级</h1><h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><h3 id="1-线程池的停止"><a href="#1-线程池的停止" class="headerlink" title="1. 线程池的停止"></a>1. 线程池的停止</h3><ol><li>shutdown** 关闭线程池，但是线程池需要正在执行的任务和队列中的任务执行完之后关闭**</li><li>shutdownNow 立刻关闭线程池，并返回任务队列中的任务。同时中断正在执行的任务</li><li>isShutdown 判断线程是否关闭</li><li>isTerminated 判断线程池是否终止运行</li><li>awaitTermination 判断线程池在判断延后的时间范围内线程池是否终止</li></ol><p>​</p><h3 id="2-拒绝策略"><a href="#2-拒绝策略" class="headerlink" title="2. 拒绝策略"></a>2. 拒绝策略</h3><ul><li>AbortPolicy 直接抛出异常</li><li>DiscardPolicy 直接抛弃任务</li><li>DiscardOldestPolicy 直接抛弃执行时间最长的任务</li><li>CallerRunsPolicy 直接返回给调用者</li></ul><p>​</p><p>​</p><h3 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h3><h4 id="1-组成部分"><a href="#1-组成部分" class="headerlink" title="1. 组成部分"></a>1. 组成部分</h4><ul><li>线程池管理器</li><li>工作线程</li><li>任务队列</li><li>任务接口</li></ul><p>​</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633444509426-74410e03-652a-40bb-98dd-0dedffb69f41.png#clientId=u23d15eed-d2bc-4&from=paste&height=276&id=u332b0768&margin=%5Bobject%20Object%5D&name=image.png&originHeight=551&originWidth=909&originalType=binary&ratio=1&size=125603&status=done&style=none&taskId=u9bf42bec-bf47-4811-bca8-b174bdd8f30&width=454.5" alt="image.png"></p><p><strong>线程池架构图</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633444552891-52b344e1-6a04-43cd-adc0-bca35a432040.png#clientId=u23d15eed-d2bc-4&from=paste&height=213&id=u2e1fbaed&margin=%5Bobject%20Object%5D&name=image.png&originHeight=425&originWidth=623&originalType=binary&ratio=1&size=63702&status=done&style=none&taskId=u366f33eb-8333-4327-b1f0-d1db3fe43f4&width=311.5" alt="image.png"></p><ul><li>Executor 线程池顶级接口</li><li>ExecutorService 线程池业务接口</li></ul><p>​</p><p><strong>线程池任务复用原理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="comment">//获取线程池状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//判断线程池状态以及任务队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//调用addWorker创建新的工作线程</span></span><br><span class="line">   <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后调用runWorker执行当前线程的任务</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>线程池状态</strong></p><ul><li>Running 接受新任务并排队处理任务</li><li>Shutdown 不接受新任务，但处理正在运行任务</li><li>Stop 不接受新任务 ，也不处理队列任务，并中断正在运行任务</li><li>Tidying 所有任务都终止，所有工作线程为 0 并接下来执行 terminated（）钩子方法</li><li>Terminated 运行完成</li></ul><h2 id="2-ThreadLocal"><a href="#2-ThreadLocal" class="headerlink" title="2. ThreadLocal"></a>2. ThreadLocal</h2><h3 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a>1. 使用场景</h3><p>​</p><ol><li>每个线程需要一个独享的对象（工具类对象 SimpleDateFormat 和 Random）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threadlocal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.SimpleFormatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/10/4</span></span><br><span class="line"><span class="comment"> * ThreadLocal 存放工日期格式化具类对象</span></span><br><span class="line"><span class="comment"> * 每个线程都需要存放一个独享的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreadLocalNormalUsage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String &gt; dateSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor poolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">100</span>, <span class="number">100</span>, <span class="number">10</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            poolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    dateParse(finalI);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dateParse</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">                    Date date = <span class="keyword">new</span> Date(<span class="number">1000</span> * i);</span><br><span class="line">                    SimpleDateFormat dateFormat = ThreadLocalDateFormatter.dateFormatThreadLocal.get();</span><br><span class="line">                    dateSet.add(dateFormat.format(date));</span><br><span class="line">                    System.out.println(dateFormat.format(date));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(dateSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDateFormatter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; dateFormatThreadLocal =</span><br><span class="line">            ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>每个线程内需要保存全局变量，可以不同方法直接使用，避免传递参数的麻烦</li></ol><h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><ol><li>多线程，对象数据数据隔离</li><li>多线程下，轻松获取获取全局变量</li></ol><p>​</p><h3 id="3-好处"><a href="#3-好处" class="headerlink" title="3. 好处"></a>3. 好处</h3><ul><li>线程安全</li><li>不需要加锁，提高效率</li><li>线程池的情况下，节省内存开销</li><li>免去多线程情况下传参麻烦</li></ul><p>​</p><p>​</p><h3 id="3-原理-、源码分析"><a href="#3-原理-、源码分析" class="headerlink" title="3. 原理 、源码分析"></a>3. 原理 、源码分析</h3><p><strong>主要方法</strong><br>​</p><ol><li><strong>initialValue()</strong></li></ol><ul><li>返回当前线程对应的初始值，延迟加载只有第一次调用 get 时候才会触发。</li><li>当线程先前调用了 set()，则不会调用 initialValue()方法</li><li>线程最多只能调用一次该方法，除非调用 remove()删除了对应的数据，在调用 get</li><li>不重写默认返回 null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前线程的ThreadLocalMap</span></span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">//如果对应的map不为空</span></span><br><span class="line">     <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//通过map获取对应的值</span></span><br><span class="line">         ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">             T result = (T)e.value;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//反之则调用初始化方法</span></span><br><span class="line">     <span class="keyword">return</span> setInitialValue();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>​</strong></p><p><strong>​</strong></p><ol start="2"><li><strong>set()</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>ThreadLocalMap 类</strong><br><strong>​</strong></p><p><strong>键：ThreadLocal 对象</strong><br><strong>值：存储对应的值</strong><br><strong>​</strong></p><p><strong>ThreadLocal 哈希冲突解决办法：线性探测法（发生冲突判断下一个位置是否为空）</strong><br><strong>​</strong></p><p><strong>​</strong></p><p><strong>​</strong></p><h3 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4. 注意点"></a>4. 注意点</h3><ul><li><strong>内存泄漏问题</strong>（对象不在使用，但却无法回收）</li></ul><p>​</p><p>​</p><p>​</p><p>​</p><h2 id="3-AQS"><a href="#3-AQS" class="headerlink" title="3. AQS"></a>3. AQS</h2><h3 id="1-原理解析"><a href="#1-原理解析" class="headerlink" title="1. 原理解析"></a>1. 原理解析</h3><h4 id="1-State-状态"><a href="#1-State-状态" class="headerlink" title="1. State 状态"></a>1. State 状态</h4><p>在不同的并发类中有不同的含义<br>Semaphore 剩余许可证的数量<br>CountDownLatch 需要倒数的数量<br>ReentrantLock 表示可重入锁的次数 当 state 表示锁不被任何线程持有</p><h4 id="2-FIFO-队列"><a href="#2-FIFO-队列" class="headerlink" title="2.FIFO 队列"></a>2.FIFO 队列</h4><ul><li>存放等待线程的双向队列</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633511736158-4641796b-4219-464d-af3b-079fff214722.png#clientId=u8f654df0-be2a-4&from=paste&height=89&id=uab7d1c76&margin=%5Bobject%20Object%5D&name=image.png&originHeight=178&originWidth=897&originalType=binary&ratio=1&size=82969&status=done&style=none&taskId=u6d281669-be18-4155-9118-8281cc4ac50&width=448.5" alt="image.png"></p><h4 id="3-工具类实现的获取-释放方法"><a href="#3-工具类实现的获取-释放方法" class="headerlink" title="3. 工具类实现的获取/释放方法"></a>3. 工具类实现的获取/释放方法</h4><ol><li>获取方法（<strong>导致线程阻塞</strong>）</li></ol><ul><li>ReentrantLock 判断 state 是否为 0，如果不为为 0 则会阻塞</li><li>Semaphore 通过 acquire 方法获取到 state,判断 state 是否为正数，是则 state-1 可以获取一个许可证</li><li>CountDownLatch 通过 await 获取 state，判断是否等于 0，如果为 0 则唤醒，反之阻塞</li></ul><p>​</p><p>​</p><ol start="2"><li>释放方法</li></ol><ul><li>Semaphore 通过使用 release 方法使 state+1</li><li>CountDownLatch countDown 方法</li></ul><p>​</p><p>​</p><p>​</p><h4 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4. 源码分析"></a>4. 源码分析</h4><h5 id="1-CountDownLatch-源码分析"><a href="#1-CountDownLatch-源码分析" class="headerlink" title="1. CountDownLatch 源码分析"></a>1. CountDownLatch 源码分析</h5><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633512858997-9e24ac55-ed62-41b7-a171-c921b56cec76.png#clientId=u8f654df0-be2a-4&from=paste&height=119&id=uabb32415&margin=%5Bobject%20Object%5D&name=image.png&originHeight=237&originWidth=672&originalType=binary&ratio=1&size=49318&status=done&style=none&taskId=ue0c7eba3-0a06-47bf-9d14-b1c1925f2f9&width=336" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1633573965910-d310e60f-33ca-4d66-be34-7e47a28dd28c.png#clientId=u5713b59d-1bde-4&from=paste&height=303&id=u0979f993&margin=%5Bobject%20Object%5D&name=image.png&originHeight=605&originWidth=917&originalType=binary&ratio=1&size=221272&status=done&style=none&taskId=u1e32547a-e975-4d63-bd2b-a1a588f6639&width=458.5" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">       <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">   &#125;</span><br><span class="line"> Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">           setState(count);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">       state = newState;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> getState();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程等待直到倒数结束</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">     <span class="comment">//判断是否倒数结束</span></span><br><span class="line">       <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">           doAcquireSharedInterruptibly(arg);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="comment">//将线程包装成一个node节点然后放入队列然后中断该线程</span></span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                   <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                   <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                       failed = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-Semaphore-源码分析"><a href="#2-Semaphore-源码分析" class="headerlink" title="2. Semaphore 源码分析"></a>2. Semaphore 源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="comment">//如果state大于0则将线程放入阻塞队列</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公平锁的方式获取资源state</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//非公平锁的方式获取资源state</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="3-ReentrantLock"><a href="#3-ReentrantLock" class="headerlink" title="3. ReentrantLock"></a>3. ReentrantLock</h5><p>​</p><p><strong>释放锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试释放当前线程的锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">//判断当前线程是否持有锁</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//判断state是否为0</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//释放锁</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>流程：<br>判断当前锁对应的线程是不是该线程如果是直接 state-1,不是抛出异常，减到 0 就返回 true。并且释放当前线程的锁</p><p><strong>加锁方法</strong><br><strong>​</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非公平加锁的实现</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//通过cas判断其他线程是否持有锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//尝试获取锁</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">         <span class="comment">//判断锁是否被持有</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">//判断锁的线程和当前线程是否是同一线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//公平锁加锁</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-实现简化版-ConuntDownLatch"><a href="#2-实现简化版-ConuntDownLatch" class="headerlink" title="2. 实现简化版 ConuntDownLatch"></a>2. 实现简化版 ConuntDownLatch</h3><p>步骤：</p><ol><li>创建一个类，实现获取/释放的方法</li><li>写一个内部类 Sync 继承 AbstractQueuedSynchronizer</li><li>根据锁是否独占来重写 tryAcquire/tryRelease 或 tryAcquireShared 和 tryReleaseShared 等方法</li></ol><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> aqs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2021/10/7</span></span><br><span class="line"><span class="comment"> * 自定义一次性门闩</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneShortLatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        OneShortLatch oneShortLatch = <span class="keyword">new</span> OneShortLatch();</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;尝试获取latch&quot;</span>);</span><br><span class="line">                oneShortLatch.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;门闩调用了放行方法&quot;</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        oneShortLatch.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m</summary>
      
    
    
    
    <category term="Java" scheme="https://xincao20.gitee.io/blog/categories/Java/"/>
    
    
    <category term="JUC" scheme="https://xincao20.gitee.io/blog/tags/JUC/"/>
    
    <category term="Java高级" scheme="https://xincao20.gitee.io/blog/tags/Java%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实战基础篇1-查询语句的执行</title>
    <link href="https://xincao20.gitee.io/blog/2021/10/17/%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C/"/>
    <id>https://xincao20.gitee.io/blog/2021/10/17/%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C/</id>
    <published>2021-10-16T16:00:00.000Z</published>
    <updated>2021-12-14T08:18:02.780Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script>console.error("Error: [hexo-tag-aplayer] Meting support is disabled, cannot resolve the meting tags properly.");</script><p><strong>MySQL逻辑架构图</strong></p><p><img src="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211016180221.png" alt="img"></p><h3 id="1-Server层"><a href="#1-Server层" class="headerlink" title="1. Server层"></a>1. Server层</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>Server层包括连接器、分析器、优化器、执行器、查询缓存。</p><h4 id="1-连接器"><a href="#1-连接器" class="headerlink" title="1. 连接器"></a>1. 连接器</h4><p>==<strong>作用：==</strong></p><ol><li><p><strong>==负责跟客户端建立连接==</strong></p></li><li><p><strong>==获取权限==</strong></p></li><li><p><strong>==维持和管理连接==</strong></p></li></ol><p>连接指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>获取权限：通过TCP握手后，连接器验证身份，通过输入的用户名和密码。查询MySQL数据库中的user表。查询对应的用户权限。</p><p><strong>长连接和短链接</strong></p><p>长连接：连接成功后，如果客户端持续有请求，则一直使用该连接</p><p>短连接：每次执行完几次查询就断开连接，下次查询在重新建立连接。</p><p>建议使用长连接，因为建立连接过程比较复杂，尽量减少建立连接的动作。</p><p>但是建立长连接也会导致内存消耗增加。因为Mysql在执行时使用的内存是在连接对象里面的。这些资源会在断开时释放。</p><p>如果长连接累计下来，可能导致内存占用太大。</p><p>解决方法</p><ol><li>定期断开长连接</li><li>执行mysql_reset_connectionc初始化连接资源。针对5.7以后。</li></ol><h4 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2. 查询缓存"></a>2. 查询缓存</h4><p><strong>==作用：用于做缓存==</strong></p><p>Mysql拿到请求后会先去缓存中，查看是否有对应的查询语句。缓存以key-value的形式存储。</p><p>查询语句作为key ,查询结果作为value存入缓存中。</p><p>但是不建议使用查询缓存。因为缓存数据失效的很频繁。</p><p><strong>8.0之后MySQL删掉了查询缓存</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//缓存查询</span><br><span class="line"></span><br><span class="line">select  SQL_CACHE *  from T ;</span><br><span class="line"></span><br><span class="line">// 不查询缓存</span><br><span class="line">select   DEMAND *  from T ; </span><br></pre></td></tr></table></figure><h4 id="3-分析器"><a href="#3-分析器" class="headerlink" title="3. 分析器"></a>3. 分析器</h4><p><strong>==作用： 进行sql语句的解析。==</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where ID=1;</span><br></pre></td></tr></table></figure><ol><li>词法分析</li></ol><p>通过关键字 <strong>select</strong> 识别为查询语句。将对应的T识别成对应的表名T，将字符串”ID” 识别成列”ID”.</p><ol><li>语法分析</li></ol><p>判断Sql语句是否满足Mysql语法。如果语句不对，则会受到错误提醒。</p><h4 id="4-优化器"><a href="#4-优化器" class="headerlink" title="4. 优化器"></a>4. 优化器</h4><p>作用：决定执行方案</p><ol><li>决定使用哪个索引，多个索引情况下。</li><li>决定各表连接顺序，多个表关联的情况下。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。</li><li>也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。</li></ul><p>优化器会决定执行哪种方案。</p><h4 id="5-执行器"><a href="#5-执行器" class="headerlink" title="5. 执行器"></a>5. 执行器</h4><p><strong>==作用：执行sql语句==</strong></p><ol><li>判断用户对这个表有无查询权限</li><li>根据表引擎提供的接口执行查询</li></ol><ul><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ul><p>####6.小结</p><ol><li><p>连接器主要作用让客户端和服务端建立连接、获取登录用户权限、维持和管理连接。</p></li><li><p>查询缓存用于通过查询的sql语句作为key，判断是否存在对应的key,如果存在直接返回缓存中存储的查询结果。</p></li><li><p>分析器用于**==判断sql语句语法是否正确==**！将查询的sql语句的字段名解析成对应的数据库中对应的字段和表</p></li><li><p>分析器作用**==优化查询条件==**。查询条件判断使用哪种索引进行查询以及各表的连接顺序</p></li><li><p>执行器用于**==执行sql语句==**。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m</summary>
      
    
    
    
    <category term="数据库" scheme="https://xincao20.gitee.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://xincao20.gitee.io/blog/tags/Mysql/"/>
    
    <category term="数据库" scheme="https://xincao20.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql实战" scheme="https://xincao20.gitee.io/blog/tags/Mysql%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL实战基础篇7-行锁</title>
    <link href="https://xincao20.gitee.io/blog/2021/10/17/%E8%A1%8C%E9%94%81/"/>
    <id>https://xincao20.gitee.io/blog/2021/10/17/%E8%A1%8C%E9%94%81/</id>
    <published>2021-10-16T16:00:00.000Z</published>
    <updated>2021-12-14T08:18:11.279Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-两阶段锁"><a href="#1-两阶段锁" class="headerlink" title="1. 两阶段锁"></a>1. 两阶段锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634436939942-730ba0be-6f13-45fd-9e43-01d1e21cdcae.png" alt="img"></p><p><strong>下面的操作序列中，如果为两行数据加了行锁事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。</strong></p><p>在InnoDB中，行锁是在需要的时候加上，在<strong>事务结束时释放。（</strong>最有可能造成锁冲突的行的读锁尽量往后放<strong>）</strong></p><p>示例：</p><p>顾客A在影院B买电影票</p><p>操作如下</p><ol><li><p>从顾客 A 账户余额中扣除电影票价；</p></li><li><p>给影院 B 的账户余额增加这张电影票价；</p></li><li><p>记录一条交易日志。</p></li></ol><p>其中多个顾客买票可能造成B的账户行数据冲突。因此将B的操作放在最后。最大程度减少了事务之间的锁等待。</p><h3 id="2-死锁和死锁检测"><a href="#2-死锁和死锁检测" class="headerlink" title="2. 死锁和死锁检测"></a>2. 死锁和死锁检测</h3><p>示例：当行锁同时锁住id=1和2的两行数据</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634437587628-d3672f2b-b62b-4ced-ac7b-dcc6de65eb02.png" alt="img"></p><p>在这种情况下事务A等待id=2的行锁，事务B等待id=1的行锁。事务A和事务B互相都在等待对方无法释放的资源，从而进入了死锁。</p><p>解决方法</p><ul><li>设置获取锁等待时间：设置获取锁超时时间，如果超时则锁住的线程自动退出。通过innodb_lock_wait_timeout来设置等待时间默认为50s</li><li>发起死锁检测：发现死锁后主动回滚争抢锁的某一个事务。让其他事务继续执行。通过innodb_deadlock_detect 设置为on表示开启逻辑。</li></ul><p>死锁检测的缺点：</p><ol><li>确保业务不会出现死锁，关闭死锁检测</li><li>控制并发度</li></ol><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><ol><li><p>读锁的两阶段协议：需要的时候加上、事务结束的时候释放。尽可能将影响并发度最大的锁往后放。减少其他锁的等待时间</p></li><li><p>死锁的形成，事务之间争抢不释放的锁资源。导致一直处于等待状态</p></li><li><p>死锁的解决方法：1. 设置锁等待时间 2. 开启死锁检测</p></li></ol><ul><li><p>第一种，直接执行 delete from T limit 10000;</p></li><li><p>第二种，在一个连接中循环执行 20 次 delete from T limit 500;</p></li><li><p>第三种，在 20 个连接中同时执行 delete from T limit 500。</p></li></ul><p>你会选择哪一种方法呢？为什么呢？</p><p>第二种，第三种容易造成死锁。第一种锁的范围太大导致获取锁的时间长。—<br>title: MySQL实战基础篇7-行锁<br>comments: true<br>date: 2021-10-17<br>tags: [Mysql,数据库,Mysql实战]<br>categories: 数据库<br>top_img: <a href="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211017122103.png">https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211017122103.png</a><br>cover: <a href="https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211017122103.png">https://gitee.com/xincao20/picgo-gitee/raw/master/img//20211017122103.png</a></p><hr><h3 id="1-两阶段锁-1"><a href="#1-两阶段锁-1" class="headerlink" title="1. 两阶段锁"></a>1. 两阶段锁</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634436939942-730ba0be-6f13-45fd-9e43-01d1e21cdcae.png" alt="img"></p><p><strong>下面的操作序列中，如果为两行数据加了行锁事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键。</strong></p><p>在InnoDB中，行锁是在需要的时候加上，在<strong>事务结束时释放。（</strong>最有可能造成锁冲突的行的读锁尽量往后放<strong>）</strong></p><p>示例：</p><p>顾客A在影院B买电影票</p><p>操作如下</p><ol><li><p>从顾客 A 账户余额中扣除电影票价；</p></li><li><p>给影院 B 的账户余额增加这张电影票价；</p></li><li><p>记录一条交易日志。</p></li></ol><p>其中多个顾客买票可能造成B的账户行数据冲突。因此将B的操作放在最后。最大程度减少了事务之间的锁等待。</p><h3 id="2-死锁和死锁检测-1"><a href="#2-死锁和死锁检测-1" class="headerlink" title="2. 死锁和死锁检测"></a>2. 死锁和死锁检测</h3><p>示例：当行锁同时锁住id=1和2的两行数据</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12394516/1634437587628-d3672f2b-b62b-4ced-ac7b-dcc6de65eb02.png" alt="img"></p><p>在这种情况下事务A等待id=2的行锁，事务B等待id=1的行锁。事务A和事务B互相都在等待对方无法释放的资源，从而进入了死锁。</p><p>解决方法</p><ul><li>设置获取锁等待时间：设置获取锁超时时间，如果超时则锁住的线程自动退出。通过innodb_lock_wait_timeout来设置等待时间默认为50s</li><li>发起死锁检测：发现死锁后主动回滚争抢锁的某一个事务。让其他事务继续执行。通过innodb_deadlock_detect 设置为on表示开启逻辑。</li></ul><p>死锁检测的缺点：</p><ol><li>确保业务不会出现死锁，关闭死锁检测</li><li>控制并发度</li></ol><h3 id="3-小结-1"><a href="#3-小结-1" class="headerlink" title="3. 小结"></a>3. 小结</h3><ol><li><p>读锁的两阶段协议：需要的时候加上、事务结束的时候释放。尽可能将影响并发度最大的锁往后放。减少其他锁的等待时间</p></li><li><p>死锁的形成，事务之间争抢不释放的锁资源。导致一直处于等待状态</p></li><li><p>死锁的解决方法：1. 设置锁等待时间 2. 开启死锁检测</p></li></ol><ul><li><p>第一种，直接执行 delete from T limit 10000;</p></li><li><p>第二种，在一个连接中循环执行 20 次 delete from T limit 500;</p></li><li><p>第三种，在 20 个连接中同时执行 delete from T limit 500。</p></li></ul><p>你会选择哪一种方法呢？为什么呢？</p><p>第二种，第三种容易造成死锁。第一种锁的范围太大导致获取锁的时间长。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m</summary>
      
    
    
    
    <category term="数据库" scheme="https://xincao20.gitee.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Mysql" scheme="https://xincao20.gitee.io/blog/tags/Mysql/"/>
    
    <category term="数据库" scheme="https://xincao20.gitee.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql实战" scheme="https://xincao20.gitee.io/blog/tags/Mysql%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://xincao20.gitee.io/blog/2021/08/10/%E7%AE%97%E6%B3%95/"/>
    <id>https://xincao20.gitee.io/blog/2021/08/10/%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-09T16:00:00.000Z</published>
    <updated>2021-12-14T08:18:08.575Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-算法基础"><a href="#第一章-算法基础" class="headerlink" title="第一章 算法基础"></a>第一章 算法基础</h1><h2 id="1-学习算法和刷题框架思维"><a href="#1-学习算法和刷题框架思维" class="headerlink" title="1. 学习算法和刷题框架思维"></a>1. 学习算法和刷题框架思维</h2><h3 id="1-数据结构构成"><a href="#1-数据结构构成" class="headerlink" title="1.数据结构构成"></a>1.数据结构构成</h3><h4 id="数据结构的本质存储方式只有两种：数组（顺序存储）和链表（链式存储）"><a href="#数据结构的本质存储方式只有两种：数组（顺序存储）和链表（链式存储）" class="headerlink" title="数据结构的本质存储方式只有两种：数组（顺序存储）和链表（链式存储）"></a>数据结构的本质存储方式只有两种：数组（顺序存储）和链表（链式存储）</h4><p>散列表、栈队列、堆、树、图等各种数据结构的基础都是由数据链表的结构基础，不断组合形成并带有某些普通数组和链表所不具备的特性。</p><p><strong>数组和链表的特点：</strong></p><ol><li><strong>数组：随机访问、节约空间、连续存储。但是必须一次性分配空间。如果空间不足需要扩容复制到新的数组中。插入和删除时间复杂度高，查找复杂度底</strong></li><li><strong>链表：不连续存储、不存在扩容复制问题、不能随机访问。插入删除删减复杂度低、查找时间复杂度高。</strong></li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="2-数据结构的基本操作"><a href="#2-数据结构的基本操作" class="headerlink" title="2. 数据结构的基本操作"></a>2. 数据结构的基本操作</h3><p><strong>遍历+访问（增删改查）</strong></p><h4 id="遍历-访问方式"><a href="#遍历-访问方式" class="headerlink" title="遍历+访问方式"></a>遍历+访问方式</h4><ol><li>线性： for、while循环</li><li>非线性： 递归</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 基本的单链表节点 */</span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void traverse(ListNode head) &#123;</span><br><span class="line">    for (ListNode p = head; p != null; p = p.next) &#123;</span><br><span class="line">        // 迭代访问 p.val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void traverse(ListNode head) &#123;</span><br><span class="line">    // 递归访问 head.val</span><br><span class="line">    traverse(head.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-刷题指南"><a href="#3-刷题指南" class="headerlink" title="3. 刷题指南"></a>3. 刷题指南</h3><p><strong>先刷二叉树！！！！</strong></p><p><strong>理由：培养刷题框架思维，大部分算法都是树的遍历问题！！！有利于理解动态规划、回溯等一些算法技巧。</strong></p><h1 id="第二章-数据结构刷题指南"><a href="#第二章-数据结构刷题指南" class="headerlink" title="第二章 数据结构刷题指南"></a>第二章 数据结构刷题指南</h1><h2 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h2><h3 id="1-二叉树的重要性"><a href="#1-二叉树的重要性" class="headerlink" title="1. 二叉树的重要性"></a>1. 二叉树的重要性</h3><p><strong>二叉树的算法思想运用广泛，许多算法那都可以抽象成二叉树相关思路去解决。</strong></p><p><strong>大部分递归算法都可以抽象成二叉树问题！！！</strong></p><h3 id="2-递归算法"><a href="#2-递归算法" class="headerlink" title="2. 递归算法"></a>2. 递归算法</h3><p>递归算法关键：</p><ol><li><p><strong>明确每个函数的作用！！！！</strong></p></li><li><p>用这个函数推导出结果</p></li><li><p><strong>不要跳入递归细节！！！</strong></p></li><li><p>明确根节点应该做什么</p></li><li><p>确定遍历顺序</p></li></ol><h3 id="3-算法实践"><a href="#3-算法实践" class="headerlink" title="3. 算法实践"></a>3. 算法实践</h3><h4 id="1-翻转二叉树"><a href="#1-翻转二叉树" class="headerlink" title="1. 翻转二叉树"></a>1. <a href="https://leetcode-cn.com/problems/invert-binary-tree/">翻转二叉树</a></h4><h5 id="1-解题思路"><a href="#1-解题思路" class="headerlink" title="1. 解题思路"></a>1. 解题思路</h5><ol><li>通过递归进行后序遍历二叉树</li><li>递归中将子树的左右节点进行交换</li></ol><h5 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">       return reverse(root);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public TreeNode reverse(TreeNode root)&#123;</span><br><span class="line">       if(root==null) return null;</span><br><span class="line">       TreeNode temp=  new TreeNode(root.val,root.left,root.right);</span><br><span class="line">       root.right=reverse(temp.left);</span><br><span class="line">       root.left=reverse(temp.right);</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2-填充每个节点的下一个右侧节点指针"><a href="#2-填充每个节点的下一个右侧节点指针" class="headerlink" title="2. 填充每个节点的下一个右侧节点指针"></a>2. <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a></h4><h5 id="1-解题思路-1"><a href="#1-解题思路-1" class="headerlink" title="1. 解题思路"></a>1. 解题思路</h5><ol><li><p>创建一个指向方法传入子树左右节点</p></li><li><p>调用左节点的子左节点、右节点</p></li><li><p>左节点的子右节点、右节点的子左节点</p></li><li><p>右节点的子左节点、右节点的子右节点</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Node connect(Node root) &#123;</span><br><span class="line">     if(root==null) return root;</span><br><span class="line">      pointNext(root.left,root.right);</span><br><span class="line">      root.next=null;</span><br><span class="line">      return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void  pointNext(Node left,Node right)&#123;</span><br><span class="line">        if(left==null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        pointNext(left.left,left.right);</span><br><span class="line">        pointNext(left.right,right.left);</span><br><span class="line">        pointNext(right.left,right.right);</span><br><span class="line">        left.next=right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-构造最大二叉树"><a href="#3-构造最大二叉树" class="headerlink" title="3.构造最大二叉树"></a>3.<a href="https://labuladong.gitee.io/algo/2/16/20/#%E6%9E%84%E9%80%A0%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91">构造最大二叉树</a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m</summary>
      
    
    
    
    <category term="算法" scheme="https://xincao20.gitee.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://xincao20.gitee.io/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://xincao20.gitee.io/blog/tags/LeetCode/"/>
    
  </entry>
  
</feed>
